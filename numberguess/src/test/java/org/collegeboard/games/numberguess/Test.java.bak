package org.collegeboard.games.numberguess;

import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.TreeMap;
import java.util.concurrent.atomic.AtomicInteger;

public class Test {

	public class Holder<T> {
		public Holder(T t) {
			this.value = t;
		}

		public T value;

		public void increment() {
			if (value instanceof Integer) {
				Integer new_name = (Integer) value;
				new_name++;
				this.value = (T) new_name;
			}
		}

		@Override
		public String toString() {
			return "Holder [value=" + value + "]";
		}
	}

	public class IntegerHolder {

		private Integer i;

		public IntegerHolder(Integer i) {
			this.i = i;
		}

		public void increment() {
			i++;
		}

		@Override
		public String toString() {
			return "IntegerHolder [i=" + i + "]";
		}

	}

	public static void main(String[] args) {
		Test t = new Test();

		// t.maxIntPlusOne();

		// t.passByReference();

		// t.maps();

		t.closure();
	}

	//Needs Java 7/8?
	private void closure() {
		//A closure that returns a string:

			  String reversed = { 
			    String s => 
			    new StringBuilder(s).reverse().toString()
			  }.invoke("abcd");  // will return "dcba"
	}

	private void maps() {
		Hashtable ht = new Hashtable();
		// ht.put(null, "null"); //NPE
		// ht.put(0, null); //NPE
		ht.put(1, "a");
		ht.put(3, "c");
		ht.put(2, "b");
		log(ht);
		ht.remove(3);
		log(ht);

		HashMap hm = new HashMap();
		hm.put(0, null);
		hm.put(100, "a100");
		hm.put(-2, "c");
		hm.put(null, "null");
		hm.put(-1, "b");
		hm.put(1, "a");
		hm.put(2, "b");
		log(hm);
		log(Collections.synchronizedMap(hm));
		hm.remove(-2);
		log(hm);

		// predictable iteration order (which is insertion order by default)
		LinkedHashMap lhm = new LinkedHashMap();
		lhm.put(0, null);
		lhm.put(100, "a100");
		lhm.put(-2, "c");
		lhm.put(null, "null");
		lhm.put(-1, "b");
		lhm.put(1, "a");
		lhm.put(2, "b");
		log(lhm);

		// iterate in the natural order
		TreeMap tm = new TreeMap();
		tm.put(0, null);
		tm.put(100, "a100");
		tm.put(-2, "c");
		// tm.put(null, "null");//NPE
		tm.put(-1, "b");
		tm.put(1, "a");
		tm.put(2, "b");
		log(tm);

	}

	private void passByReference() {
		Integer i = 3;
		log(i);
		increment(i);
		log(i);
		IntegerHolder ih = new IntegerHolder(i);
		log(ih);
		increment(ih);
		log(ih);
		Date d = new Date();
		log(d);
		increment2(d);
		log(d);
		increment(d);
		log(d);
		increment2(d);
		log(d);
		double[] arr = { 1, 2 };
		log(Arrays.toString(arr));
		increment(arr);
		log(Arrays.toString(arr));
		AtomicInteger ai = new AtomicInteger(1);
		log(ai);
		increment(ai);
		log(ai);
		Holder<Integer> h = new Holder<Integer>(1);
		log(h);
		h.increment();
		log(h);
	}

	private void increment(AtomicInteger ai) {
		ai.addAndGet(1);
	}

	private void increment(double[] arr) {
		arr[0] = arr[0] + 1;
		arr[1] = arr[1] + 1;

	}

	private void increment(Date d) {
		d.setTime(d.getTime() + 3600 * 1000);
	}

	private void increment2(Date d) {
		d = new Date(d.getTime() + 3600 * 1000);
	}

	private void increment(IntegerHolder ih) {
		ih.increment();
	}

	private static void increment(Integer i) {
		i = i++;
	}

	private void maxIntPlusOne() {
		int i = Integer.MAX_VALUE;
		log(i);
		log(i + 1);
		log(Integer.MIN_VALUE);
	}

	private void log(Object o) {
		System.out.println(o);
	}
}
